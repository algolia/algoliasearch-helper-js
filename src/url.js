'use strict';

/**
 * Module containing the functions to serialize and deserialize
 * {SearchParameters} in the query string format
 * @module algoliasearchHelper.url
 */

var shortener = require('./SearchParameters/shortener');
var SearchParameters = require('./SearchParameters');

var qs = require('qs');

var bind = require('lodash/function/bind');
var forEach = require('lodash/collection/forEach');
var pick = require('lodash/object/pick');
var map = require('lodash/collection/map');
var mapKeys = require('lodash/object/mapKeys');
var mapValues = require('lodash/object/mapValues');
var isString = require('lodash/lang/isString');
var isPlainObject = require('lodash/lang/isPlainObject');
var isArray = require('lodash/lang/isArray');
var encode = require('qs/lib/utils').encode;

function recursiveEncode(input) {
  if (isPlainObject(input)) {
    return mapValues(input, recursiveEncode);
  }
  if (isArray(input)) {
    return map(input, recursiveEncode);
  }
  if (isString(input)) {
    return encode(input);
  }
  return input;
}

var stateKeys = shortener.ENCODED_PARAMETERS;
function sortQueryStringValues(
  prefixRegexp,
  queryParameter,
  refinementsParameters,
  a,
  b
) {
  if (prefixRegexp !== null) {
    a = a.replace(prefixRegexp, '');
    b = b.replace(prefixRegexp, '');
  }

  if (stateKeys.indexOf(a) !== -1 || stateKeys.indexOf(b) !== -1) {
    if (a === queryParameter) return -1;
    if (b === queryParameter) return 1;

    var isARefinements = refinementsParameters.indexOf(a) !== -1;
    var isBRefinements = refinementsParameters.indexOf(b) !== -1;
    if (isARefinements && !isBRefinements) {
      return 1;
    } else if (isBRefinements && !isARefinements) {
      return -1;
    }
  }

  return a.localeCompare(b);
}

/**
 * Shortener tools used inside this module
 * @type {object}
 */
exports.shortener = shortener;

/**
 * Read a query string and return an object containing the state
 * @param {string} queryString the query string that will be decoded
 * @param {object} options accepted options :
 *   - prefix : the prefix used for the saved attributes, you have to provide the
 *     same that was used for serialization
 * @return {object} partial search parameters object (same properties than in the
 * SearchParameters but not exhaustive)
 */
exports.getStateFromQueryString = function(queryString, options) {
  var prefixForParameters = options && options.prefix || '';

  var partialStateWithPrefix = qs.parse(queryString);
  var prefixRegexp = new RegExp('^' + prefixForParameters);
  var partialState = mapKeys(
    partialStateWithPrefix,
    function(v, k) {
      if (prefixForParameters && prefixRegexp.test(k)) {
        var encodedKey = k.replace(prefixRegexp, '');
        return shortener.decode(encodedKey);
      }
      var decodedKey = shortener.decode(k);
      return decodedKey || k;
    }
  );

  var partialStateWithParsedNumbers = SearchParameters._parseNumbers(partialState);

  return pick(partialStateWithParsedNumbers, SearchParameters.PARAMETERS);
};

/**
 * Retrieve an object of all the properties that are not understandable as helper
 * parameters.
 * @param {string} queryString the query string to read
 * @param {object} options the options
 *   - prefixForParameters : prefix used for the helper configuration keys
 * @return {object} the object containing the parsed configuration that doesn't
 * to the helper
 */
exports.getUnrecognizedParametersInQueryString = function(queryString, options) {
  var prefixForParameters = options && options.prefix;

  var foreignConfig = {};
  var config = qs.parse(queryString);
  if (prefixForParameters) {
    var prefixRegexp = new RegExp('^' + prefixForParameters);
    forEach(config, function(v, key) {
      if (!prefixRegexp.test(key)) foreignConfig[key] = v;
    });
  } else {
    forEach(config, function(v, key) {
      if (!shortener.decode(key)) foreignConfig[key] = v;
    });
  }

  return foreignConfig;
};

/**
 * Generate a query string for the state passed according to the options
 * @param {SearchParameters} state state to serialize
 * @param {object} [options] May contain the following parameters :
 *  - prefix : prefix in front of the keys
 *  - moreAttributes : more values to be added in the query string. Those values
 *    won't be prefixed.
 * @return {string} the query string
 */

var longRefinementsParameters = [
  'disjunctiveFacetsRefinements',
  'facetsRefinements',
  'numericRefinements',
  'hierarchicalFacetsRefinements',
  'tagRefinements'
];
exports.getQueryStringFromState = function(state, options) {
  var moreAttributes = options && options.moreAttributes;
  var prefixForParameters = options && options.prefix || '';
  var partialStateWithEncodedValues = recursiveEncode(state);

  var encodedState = mapKeys(
    partialStateWithEncodedValues,
    function(v, k) {
      var shortK = shortener.encode(k);
      return prefixForParameters + shortK;
    }
  );

  var prefixRegexp = prefixForParameters === '' ? null : new RegExp('^' + prefixForParameters);
  var shortRefinementsParameters = map(longRefinementsParameters, shortener.encode);
  var sort = bind(
    sortQueryStringValues,
    null,
    prefixRegexp,
    shortener.encode('query'),
    shortRefinementsParameters
  );
  if (moreAttributes) {
    var stateQs = qs.stringify(encodedState, {encode: false, sort: sort});
    var moreQs = qs.stringify(moreAttributes, {encode: false});
    if (!stateQs) return moreQs;
    return stateQs + '&' + moreQs;
  }

  return qs.stringify(encodedState, {encode: false, sort: sort});
};
